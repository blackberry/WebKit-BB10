#!/usr/bin/perl -w
#
# Copyright (C) Research In Motion Limited 2010. All rights reserved.
#

use strict;

use File::Path;
use Getopt::Long;
use Cwd;

use IDLParser;

# FIXME: copied from CodeGeneratorJS.pm - should be imported and not copied
sub IsSVGTypeNeedingContextParameter
{
    my $implClassName = shift;

    return 0 unless $implClassName =~ /SVG/;
    return 0 if $implClassName =~ /Element/;
    my @noContextNeeded = ("SVGPaint", "SVGColor", "SVGDocument", "SVGZoomEvent");
    foreach (@noContextNeeded) {
        return 0 if $implClassName eq $_;
    }
    return 1;
}

my $verbose = 0;

my $outputDirectory;
my $outputBase;
my $defines;
my $preprocessor;

GetOptions('outputDir=s' => \$outputDirectory,
           'outputBase=s' => \$outputBase,
           'defines=s' => \$defines,
           'preprocessor=s' => \$preprocessor);

die('Must specify input directory.') unless defined($ARGV[0]);
die('Must specify output directory.') unless defined($outputDirectory);
die('Must specify output base filename.') unless defined($outputBase);
die('Must specify defines') unless defined($defines);

$defines =~ s/^\s+|\s+$//g; # trim whitespace

my $headerFileName = "$outputDirectory/$outputBase.h";
my $implFileName = "$outputDirectory/$outputBase.cpp";

# Remove old files.
unlink($headerFileName);
unlink($implFileName);

my @headerHeader = ();
my @headerContents = ();
my @implHeader = ();
my @implContents = ();

push(@headerHeader, "/*\n * Copyright (C) Research In Motion Limited 2010. All rights reserved.\n */\n\n");
push(@headerHeader, "#ifndef ${outputBase}_h\n");
push(@headerHeader, "#define ${outputBase}_h\n\n");
push(@headerHeader, "#include <JavaScriptCore/JavaScript.h>\n\n");
push(@headerHeader, "namespace WebCore {\n");

push(@implHeader, "/*\n * This file is part of the WebKit open source project.\n * This file has been generated by generate-jscdom.pl. DO NOT MODIFY!\n */\n\n");
push(@implHeader, "#include \"config.h\"\n");
push(@implHeader, "#include \"$outputBase.h\"\n\n");
push(@implHeader, "#include \"APICast.h\"\n");
push(@implHeader, "#include \"APIShims.h\"\n");
push(@implHeader, "#include \"JSGlobalObject.h\"\n\n");

my $inputDir = shift(@ARGV);
foreach my $idlFile (@ARGV) {
    # Parse the given IDL file.
    my $parser = IDLParser->new(1);
    my $document = $parser->Parse("$inputDir/$idlFile", $defines, $preprocessor);

    # Generate desired output for given IDL file.
    my $classes = $document->classes;
    foreach my $class (@$classes) {
        my $name = $class->name;
        $name =~ s/[a-zA-Z0-9]*:://;

        next if (!($name eq "DOMWindow") && (@{$class->parents} > 0 || $class->extendedAttributes->{"LegacyParent"}));
        next if ($name eq "VoidCallback" || $name eq "AbstractWorker");

        # Callbacks have no converter functions
        next if $class->extendedAttributes->{"Callback"};

        # FIXME: SVGAnimated* classes use templated base classes.  Should figure out how to generate appropriate converter functions, but for now just skip them
        next if $name =~ /^SVGAnimated/;

        # FIXME: POD types need different converters.  Should figure out how to generate these, but for now just skip them
        next if $class->extendedAttributes->{"PODType"};

        # FIXME: many SVG classes need a context parameter.  Should figure out how to get it, but for now just skip them
        next if IsSVGTypeNeedingContextParameter($class->name);

        print "Generating $outputBase bindings code for IDL interface \"" . $class->name . "\"...\n" if $verbose;

        push(@headerHeader, "class $name;\n");
        push(@headerContents, "\nWebCore::$name* JSValueTo$name(JSContextRef ctx, JSValueRef value);\n");
        push(@headerContents, "JSValueRef JSValueFrom$name(JSContextRef ctx, JSValueRef domGlobal, WebCore::$name* webcoreObject);\n");

        push(@implHeader, "#include \"JS$name.h\"\n");
        my $conditional = $class->extendedAttributes->{"Conditional"};
        if ($conditional) {
            push(@implContents, "\n#if ENABLE(" . join(") && ENABLE(", split(/&/, $conditional)) . ")\n");
        }
        push(@implContents, "\nWebCore::$name* JSValueTo$name(JSContextRef ctx, JSValueRef value)\n");
        push(@implContents, "{\n");
        push(@implContents, "    JSC::ExecState* exec = toJS(ctx);\n");
        push(@implContents, "    JSC::APIEntryShim entryShim(exec);\n\n");
        push(@implContents, "    JSC::JSValue jsValue = toJS(exec, value);\n");
        if ($name eq "NodeFilter") {
            push(@implHeader, "#include \"NodeFilter.h\"\n");
            push(@implContents, "    return WebCore::to$name(jsValue).get();\n");
        } else {
            push(@implContents, "    return WebCore::to$name(jsValue);\n");
        }
        push(@implContents, "}\n\n");
        push(@implContents, "JSValueRef JSValueFrom$name(JSContextRef ctx, JSValueRef domGlobal, WebCore::$name* webcoreObject)\n");
        push(@implContents, "{\n");
        push(@implContents, "    JSC::ExecState* exec = toJS(ctx);\n");
        push(@implContents, "    JSC::APIEntryShim entryShim(exec);\n\n");
        push(@implContents, "    JSC::JSGlobalObject* globalObject = JSC::asGlobalObject(toJS(exec, domGlobal));\n");
        if ($name eq "DOMWindow") {
            push(@implContents, "    JSC::JSValue value = WebCore::toJS(exec, static_cast<WebCore::JSDOMGlobalObject*>(globalObject), webcoreObject);\n");
        } else {
            push(@implContents, "    JSC::JSValue value = toJS(exec, static_cast<WebCore::JSDOMGlobalObject*>(globalObject), webcoreObject);\n");
        }
        push(@implContents, "    return toRef(exec, value);\n");
        push(@implContents, "}\n");
        if ($conditional) {
            push(@implContents, "\n#endif\n");
        }
    }
}

push(@headerHeader, "}\n");
push(@headerContents, "#endif\n");

open(HEADER, ">$headerFileName") or die "Couldn't open file $headerFileName";
open(IMPL, ">$implFileName") or die "Couldn't open file $implFileName";

print HEADER @headerHeader;
print HEADER @headerContents;
print IMPL @implHeader;
print IMPL @implContents;

close(HEADER);
close(IMPL);
